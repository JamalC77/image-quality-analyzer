{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useRef } from 'react';\nimport { analyzeImageQuality } from '../utils/imageAnalyzer';\nconst ImageAnalyzer = ({\n  image,\n  config,\n  onAnalysisComplete\n}) => {\n  _s();\n  const [analyzing, setAnalyzing] = useState(false);\n  const lastImageRef = useRef(null);\n  const timeoutRef = useRef(null);\n\n  // Start analysis when a new image arrives\n  useEffect(() => {\n    // Only process if there's an image and it's different from the last one\n    if (image && (!lastImageRef.current || lastImageRef.current.id !== image.id) && !analyzing) {\n      // Update the last image reference\n      lastImageRef.current = image;\n      setAnalyzing(true);\n\n      // Clear any existing timeout\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      // Set up a new timeout that represents the analysis time (min 500ms)\n      timeoutRef.current = setTimeout(() => {\n        const feedback = analyzeImageQuality(image, config);\n        onAnalysisComplete(feedback);\n        setAnalyzing(false);\n      }, Math.max(config.analysisDelay, 500)); // Ensure minimum analysis time of 500ms\n    }\n\n    // Clean up on unmount\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [image, config, onAnalysisComplete, analyzing]);\n\n  // No visual render - this is just a functional component\n  return null;\n};\n_s(ImageAnalyzer, \"7qRX3zrw410+hHCrlY1I2TR0htw=\");\n_c = ImageAnalyzer;\nexport default ImageAnalyzer;\nvar _c;\n$RefreshReg$(_c, \"ImageAnalyzer\");","map":{"version":3,"names":["useEffect","useState","useRef","analyzeImageQuality","ImageAnalyzer","image","config","onAnalysisComplete","_s","analyzing","setAnalyzing","lastImageRef","timeoutRef","current","id","clearTimeout","setTimeout","feedback","Math","max","analysisDelay","_c","$RefreshReg$"],"sources":["C:/Users/jamal/OneDrive/Documents/Development/Test Projects/image-quality-analyzer/src/components/ImageAnalyzer.tsx"],"sourcesContent":["import React, { useEffect, useState, useRef } from 'react';\r\nimport { ImageAnalyzerProps, MockImage } from '../types';\r\nimport { analyzeImageQuality } from '../utils/imageAnalyzer';\r\n\r\nconst ImageAnalyzer: React.FC<ImageAnalyzerProps> = ({\r\n  image,\r\n  config,\r\n  onAnalysisComplete\r\n}) => {\r\n  const [analyzing, setAnalyzing] = useState(false);\r\n  const lastImageRef = useRef<MockImage | null>(null);\r\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  // Start analysis when a new image arrives\r\n  useEffect(() => {\r\n    // Only process if there's an image and it's different from the last one\r\n    if (image && (!lastImageRef.current || lastImageRef.current.id !== image.id) && !analyzing) {\r\n      // Update the last image reference\r\n      lastImageRef.current = image;\r\n      setAnalyzing(true);\r\n\r\n      // Clear any existing timeout\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n\r\n      // Set up a new timeout that represents the analysis time (min 500ms)\r\n      timeoutRef.current = setTimeout(() => {\r\n        const feedback = analyzeImageQuality(image, config);\r\n        onAnalysisComplete(feedback);\r\n        setAnalyzing(false);\r\n      }, Math.max(config.analysisDelay, 500)); // Ensure minimum analysis time of 500ms\r\n    }\r\n\r\n    // Clean up on unmount\r\n    return () => {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n    };\r\n  }, [image, config, onAnalysisComplete, analyzing]);\r\n\r\n  // No visual render - this is just a functional component\r\n  return null;\r\n};\r\n\r\nexport default ImageAnalyzer; "],"mappings":";AAAA,SAAgBA,SAAS,EAAEC,QAAQ,EAAEC,MAAM,QAAQ,OAAO;AAE1D,SAASC,mBAAmB,QAAQ,wBAAwB;AAE5D,MAAMC,aAA2C,GAAGA,CAAC;EACnDC,KAAK;EACLC,MAAM;EACNC;AACF,CAAC,KAAK;EAAAC,EAAA;EACJ,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGT,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAMU,YAAY,GAAGT,MAAM,CAAmB,IAAI,CAAC;EACnD,MAAMU,UAAU,GAAGV,MAAM,CAAwB,IAAI,CAAC;;EAEtD;EACAF,SAAS,CAAC,MAAM;IACd;IACA,IAAIK,KAAK,KAAK,CAACM,YAAY,CAACE,OAAO,IAAIF,YAAY,CAACE,OAAO,CAACC,EAAE,KAAKT,KAAK,CAACS,EAAE,CAAC,IAAI,CAACL,SAAS,EAAE;MAC1F;MACAE,YAAY,CAACE,OAAO,GAAGR,KAAK;MAC5BK,YAAY,CAAC,IAAI,CAAC;;MAElB;MACA,IAAIE,UAAU,CAACC,OAAO,EAAE;QACtBE,YAAY,CAACH,UAAU,CAACC,OAAO,CAAC;MAClC;;MAEA;MACAD,UAAU,CAACC,OAAO,GAAGG,UAAU,CAAC,MAAM;QACpC,MAAMC,QAAQ,GAAGd,mBAAmB,CAACE,KAAK,EAAEC,MAAM,CAAC;QACnDC,kBAAkB,CAACU,QAAQ,CAAC;QAC5BP,YAAY,CAAC,KAAK,CAAC;MACrB,CAAC,EAAEQ,IAAI,CAACC,GAAG,CAACb,MAAM,CAACc,aAAa,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3C;;IAEA;IACA,OAAO,MAAM;MACX,IAAIR,UAAU,CAACC,OAAO,EAAE;QACtBE,YAAY,CAACH,UAAU,CAACC,OAAO,CAAC;MAClC;IACF,CAAC;EACH,CAAC,EAAE,CAACR,KAAK,EAAEC,MAAM,EAAEC,kBAAkB,EAAEE,SAAS,CAAC,CAAC;;EAElD;EACA,OAAO,IAAI;AACb,CAAC;AAACD,EAAA,CAxCIJ,aAA2C;AAAAiB,EAAA,GAA3CjB,aAA2C;AA0CjD,eAAeA,aAAa;AAAC,IAAAiB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}